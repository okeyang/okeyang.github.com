<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[文章类别：iOS | Edward Yang的博客]]></title>
  <link href="http://yang6512.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yang6512.github.io/"/>
  <updated>2015-02-12T11:49:34+08:00</updated>
  <id>http://yang6512.github.io/</id>
  <author>
    <name><![CDATA[Edward Yang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iproxy-通过USB使用SSH连接iOS设备]]></title>
    <link href="http://yang6512.github.io/blog/2013/09/16/iproxy-tong-guo-usbshi-yong-sshlian-jie-iosshe-bei/"/>
    <updated>2013-09-16T20:56:00+08:00</updated>
    <id>http://yang6512.github.io/blog/2013/09/16/iproxy-tong-guo-usbshi-yong-sshlian-jie-iosshe-bei</id>
    <content type="html"><![CDATA[<p>越狱之后用到<code>SSH</code>时需要通过<code>Wi-Fi</code>来连接，输入命令时反应比较慢，还容易掉线，尤其是在越狱开发时，有时会有砸设备、砸Mac的冲动，当然我砸不起，只是想想。</p>

<p>如果能通过USB连接就好了，既不需要依赖<code>Wi-Fi</code>，而且速度非常快，感谢开源社区的大牛们，<a href="http://cgit.sukimashita.com/usbmuxd.git/">usbmuxd</a>开源库就顺带实现了这个功能。</p>

<p>通过<a href="http://brew.sh/">brew</a>来安装（当然也可以自己去下源码手动安装，由于依赖项比较多，所以很繁琐）
<code>sh
brew install usbmuxd
</code>
安装<code>usbmuxd</code>库之后，就顺带安装了一个小工具<code>iproxy</code>，该工具会将设备上的端口号映射到电脑上的某一个端口，例如：
<code>sh
iproxy 2222 22
</code>
以上命令就是把当前连接设备的22端口(SSH端口)映射到电脑的2222端口，那么想和设备22端口通信，直接和本地的2222端口通信就可以了。
因此，SSH连接设备就可以这样连接了：
<code>sh
ssh -p 2222 root@127.0.0.1
</code>
这样就再也不用依赖<code>Wi-Fi</code>了，而且反应很流畅，当然此工具不仅可以用于SSH，也可以映射其他端口，这个就看个人需求了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC与非ARC下的Weak-Strong Dance]]></title>
    <link href="http://yang6512.github.io/blog/2013/07/29/arcyu-fei-arcxia-de-weak-strong-dance/"/>
    <updated>2013-07-29T17:16:00+08:00</updated>
    <id>http://yang6512.github.io/blog/2013/07/29/arcyu-fei-arcxia-de-weak-strong-dance</id>
    <content type="html"><![CDATA[<h2>ARC</h2>

<p>在使用block过程中，经常会遇到<code>retain cycle</code>的问题，例如：
```objc
&ndash; (void)dealloc
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] removeObserver:_observer];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)loadView
{
  [super loadView];</p>

<p>  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;testKey&rdquo;
                                                                object:nil
                                                                 queue:nil
                                                            usingBlock:^(NSNotification *note) {
      [self dismissModalViewControllerAnimated:YES];<br/>
  }];
}
<code>``
在block中用到了self，self会被block retain，而\_observer会copy一份该block，就是说\_observer间接持有self，同时当前的self也会retain \_observer，最终导致self持有_observer，\_observer持有self，形成</code>retain cycle`。</p></li>
</ul>


<p>对于在block中的<code>retain cycle</code>，在2011 WWDC Session #322 (Objective-C Advancements in Depth)有一个解决方案<code>weak-strong dance</code>，很漂亮的名字。其实现如下：
```objc
&ndash; (void)dealloc
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] removeObserver:_observer];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)loadView
{
  [super loadView];</p>

<p>  <strong>weak TestViewController <em>wself = self;
  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;testKey&rdquo;
                                                                object:nil
                                                                 queue:nil
                                                            usingBlock:^(NSNotification </em>note) {
      TestViewController *sself = wself;
      [sself dismissModalViewControllerAnimated:YES];
  }];
}
<code>``
在block中使用self之前先用一个</code></strong>weak<code>变量引用self，导致block不会retain self，打破retain cycle，然后在block中使用wself之前先用</code>__strong`类型变量引用wself，以确保使用过程中不会dealloc。简而言之就是推迟对self的retain，在使用时才进行retain。这有点像lazy loading的意思。</p></li>
</ul>


<p>注：iOS5以下没有<code>__weak</code>，则需使用<code>__unsafe_unretained</code>。</p>

<h2>非ARC</h2>

<p>在非ARC环境中，显然之前的使用的<code>__weak</code>或<code>__unsafe_unretained</code>将会是无效的，那么我们需使用另外一种方法来代替，这里就需要用到<code>__block</code>。</p>

<p><code>__block</code>在ARC和非ARC中有点细微的差别（<a href="http://www.mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html">Automatic Reference Counting : Blocks</a>）：</p>

<ul>
<li>在ARC中，<code>__block</code>会自动进行retain</li>
<li>在非ARC中，<code>__block</code>不会自动进行retain</li>
</ul>


<p>因此首先要注意的一点就是用<code>__block</code>打破<code>retain cycle</code>的方法仅在非ARC下有效，下面是非ARC的<code>weak-strong dance</code>：
```objc
&ndash; (void)dealloc
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] removeObserver:_observer];
[_observer release];

[super dealloc];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)loadView
{
  [super loadView];</p>

<p>  <strong>block TestViewController <em>bself = self;
  _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&ldquo;testKey&rdquo;
                                                                object:nil
                                                                 queue:nil
                                                               ngBlock:^(NSNotification </em>note) {
      [bself retain];
      [bself dismissModalViewControllerAnimated:YES];
      [bself release];
  }];
}
<code>``
将self赋值为</code></strong>block<code>类型变量，在非ARC中</code>__block`类型变量不会进行retain，从而打破retain cycle，然后在使用bself前进行retain，以确保在使用过程中不会dealloc。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企业开发者证书(In-House Distribution)相关问题解答]]></title>
    <link href="http://yang6512.github.io/blog/2013/07/24/qi-ye-kai-fa-zhe-zheng-shu-xiang-guan-wen-ti-jie-da/"/>
    <updated>2013-07-24T16:00:00+08:00</updated>
    <id>http://yang6512.github.io/blog/2013/07/24/qi-ye-kai-fa-zhe-zheng-shu-xiang-guan-wen-ti-jie-da</id>
    <content type="html"><![CDATA[<p><img src="http://yang6512.github.io/images/2013/ios_developer_enterprise_program.png">
最近对企业开发者证书（299刀的）产生了兴趣，查找发现相关资料很少，因此整理了一下相关资料，希望对有同样问题的朋友有所帮助。</p>

<h2>1、是否有分发设备数目限制？</h2>

<p>如果使用<code>Ad-hoc</code>证书是有限制的，100个设备，但用<code>In-House Distribution</code>证书就不存限制了，可以说它是iOS中权限最大的证书（不仅没有分发数目限制，而且可以通过多种途径分发app，更重要的是不需要进行应用程序审核）。</p>

<h2>2、是否需要绑定UDID？</h2>

<p><code>Ad-hoc</code>需要，毕竟只是用于测试目的的。<code>In-House Distribution</code>不需要。</p>

<h2>3、企业开发者证书能在App store发布应用程序吗？</h2>

<p>不能，需要另外购买99刀的开发者证书。</p>

<h2>4、In-House Distribution证书如何分发app？</h2>

<ul>
<li>将应用程序分发给用户以使用<code>iTunes</code>进行安装。</li>
<li>让IT管理员使用<code>iPhone 配置实用工具</code>或<code>Apple Configurator</code>将应用程序安装在设备上。</li>
<li>将应用程序发布到安全 Web 服务器；用户以无线方式访问和执行安装（OTA）。</li>
<li>使用MDM服务器来指示受管设备安装内部应用程序或 App Store 应用程序（如果MDM服务器支持该功能）。</li>
</ul>


<h2>5、In-House Distribution证书泄露怎办？</h2>

<p>如果泄露，可能导致外部人员使用企业app，此时可以撤销证书，然后生成新证书重新分发app。这样旧证书分发的app就无法使用了。原理是这样的：用户首次打开应用程序时，会通过联系 Apple 的 OCSP 服务器来验证分发证书，OCSP 响应会在设备上缓存一段时间（OCSP 服务器所指定的时间段），一般为 3 天到 7 天之间。在此期间将不会再次检查证书的有效性，直至设备重新启动且缓存的响应过期为止。如果那时收到撤销命令，则应用程序将被阻止运行。</p>

<h2>6、能使用In-House Distribution随意分发app，建立类似第三方App store吗？</h2>

<p>理论上可以，但是这是违反Apple协议的，这是要负法律责任的。一般能申请得到企业开发者证书的都是500人以上具有一定规模的企业，这样的企业不会明目张胆去违反Apple的协议。再说，在上一个问题中说明的证书验证原理表明，Apple有能力监控到一个<code>In-House Distribution</code>分发的app的用户使用情况，当发现有明显异常（随意分发的用户人数肯定远大于公司员工人数），相信Apple不会坐视不管。话又说回来，只是少量的分发给一些客户或个人的话，这也没有什么大碍。因此这完全取决于随意分发的量。</p>

<h2>参考链接</h2>

<ol>
<li><p><a href="http://developer.apple.com/library/ios/#featuredarticles/FA_Wireless_Enterprise_App_Distribution/Introduction/Introduction.html">Distributing Enterprise Apps for iOS Devices</a></p></li>
<li><p><a href="http://www.linkedin.com/groups/Has-anyone-had-experience-iOS-72283.S.52864455">Has anyone had experience with the iOS Developer Enterprise program?</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xCode下自动打包为ipa文件]]></title>
    <link href="http://yang6512.github.io/blog/2013/07/05/xcodexia-zi-dong-da-bao-wei-ipawen-jian/"/>
    <updated>2013-07-05T12:58:00+08:00</updated>
    <id>http://yang6512.github.io/blog/2013/07/05/xcodexia-zi-dong-da-bao-wei-ipawen-jian</id>
    <content type="html"><![CDATA[<p>最近经常给测试发包，用老办法的话总是先生成app文件，然后拖到iTunes下生成ipa文件，虽然说过程简单，但重复做这么件事总会觉得麻烦。因此用xCode命令行工具提供的<code>xcrun</code>工具写成shell，然后再添加到xCode的工程下，这样就很方便的在每次build之后就能生成相应的ipa文件。shell如下：
``` sh</p>

<h1>!/bin/sh</h1>

<p>rm -rdf build
mkdir build
exec >&amp; build/shell.log</p>

<p>/usr/bin/xcrun -sdk iphoneos PackageApplication -v &ldquo;$BUILT_PRODUCTS_DIR/$PRODUCT_NAME.app&rdquo; -o &ldquo;$SRCROOT/build/$PRODUCT_NAME.ipa&rdquo;
<code>``
会在工程根目录下生成一个build文件夹，然后会把生成的日志和ipa文件放到文件夹下。
然后在project下的</code>Build Phase<code>下</code>Add Run Script`将shell路径添加进去。
<img src="http://yang6512.github.io/images/2013/add_script_in_xcode.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在打包时将文件放入Documents目录]]></title>
    <link href="http://yang6512.github.io/blog/2013/05/24/ru-he-zai-da-bao-shi-jiang-wen-jian-fang-ru-documentsmu-lu/"/>
    <updated>2013-05-24T14:31:00+08:00</updated>
    <id>http://yang6512.github.io/blog/2013/05/24/ru-he-zai-da-bao-shi-jiang-wen-jian-fang-ru-documentsmu-lu</id>
    <content type="html"><![CDATA[<p>今天遇到一个这样的问题，想在打包时将一些文件放进<code>Documents</code>目录下，这样用户能在一开始就能有一些文件可用。像类似于一些阅读类app就经常将几本默认书籍放入<code>Documents</code>目录下。</p>

<p>首先我们来看一下一个应用程序的文件结构：</p>

<p><img src="http://yang6512.github.io/images/2013/ios_app_layout.jpg"></p>

<p>如图，可以看出<code>.app</code>文件和<code>Documents</code>文件夹处于同一级，而<code>.app</code>文件正是我们build时打包生成的应用程序文件，我们向project中添加的resource文件也当然只处于<code>.app</code>中。这样，就想到在<code>Info.plist</code>中会不会有这样的设置，可以在应用程序安装时将指定文件添加到<code>Documents</code>目录，很可惜，没有这样的设置。</p>

<p>那么，现在看来，要实现这样的功能就只能曲线救国了，思路如下：</p>

<p>将文件随app一起打包，然后在程序第一次运行时将这些文件通过代码copy到<code>Documents</code>目录下，当然要记录一个状态位，每次去读取这个状态位来进行判断。</p>
]]></content>
  </entry>
  
</feed>
